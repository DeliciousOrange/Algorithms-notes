# Algorithms's notes

1、iterator存在的目的不是为了替代for循环，也不是为性能而生，主要用于用抽象的手段隔离内部的实现细节。  
2、归并排序对于小的子数组开销有些大（因为需要迭代调用，这样就会创建大量小数组），实践中可行的一个改进是：当数组小于等于7时使用插入排序，运行时间大约快20%左右  
3、java的comparable API实现的是total order全序关系，简单来说，就是数组中的items能够按照特定顺序排列，全序关系是一种binary relation <=，满足三个关系式：  
+ 非对称性 如果v<=w，并且w<=v，那么v=w
+ 传递性   如果v<=w，并且w<=x,那么v<=x
+ 完整性   要么v<=w，要么w<=v，要么两者相等  
值得注意的是：double类型不满足全序关系，因为Double.NaN <= Double.NaN为false。    
我们日常接触到的对自然数的标准排序、字符串的字母表排序以及对日期按年份的排序都是全序排序。

4、在java中，callback的实现是通过interface实现的。类似的，c#是通过delegate实现的，c是通过函数指针实现的，c++是通过class-type functors实现的，python和js是通过first-class functions实现的。  
5、选择排序的运行时间和数据的顺序无关，它总是需要平方的时间，即使数据是有序的，因为它总是需要遍历一遍右边剩下的未排序元素来找到最小的元素；但它需要的数据移动次数是最小的，仅仅使用线性增长次数的数据交换，每个item仅使用一次exchange就被放到了它最终应该待的有序位置。  
6、在java里赋值操作的平摊成本差不多可以说是恒定的（如果不把深拷贝算在赋值里面的话），compare操作的平摊成本可以无限大（如果你真的写过hashCode、equals或compare操作就会懂得）。
7、归并排序之所以要对半分的原因在于：只有对半分产生的递归树深度最小，为lgN。每层的代价都是N，所以二分归并算法复杂度是O(NlgN)。其他任何分法都不可能有更矮的递归树。最坏的情况是一边只有一个元素，另一边N-1个，递归树深度为N，因此，复杂度为O(N^2)。这也是快排中需要避免的切分方式。
